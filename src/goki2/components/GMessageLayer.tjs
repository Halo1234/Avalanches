/*
 * $Author$
 * $Revision$
**/


/**/
class GCharacterLayer extends GWidgetLayer
{
	function GCharacterLayer(window, parent, handler)
	{
		super.GWidgetLayer(...);
		hitThreshold = 256;
		captionAlign = 0;
		bodyOpacity = 0;
	}

	function drawCaption(offx = 0, offy = 0, color = parent.captionColor, edge = parent.edgeColor, shadow = parent.shadowColor, shadowOffsetX = parent.shadowOffsetX, shadowOffsetY = parent.shadowOffsetY, shadowExtent = parent.shadowExtent)
	{
		if(font.face[0] == '@')
			super.drawCaption(font.height, offy, color, edge, shadow, shadowOffsetX, shadowOffsetY, shadowExtent);
		else
			super.drawCaption(offx, offy, color, edge, shadow, shadowOffsetX, shadowOffsetY, shadowExtent);
	}

	/**/
	function alignToHeight(align, str)
	{
		return 0;
	}

	/**/
	function alignToWidth(align, str)
	{
		return 0;
	}
}


/**/
class GRubyTextLayer extends GCharacterLayer
{
	function GRubyTextLayer(window, parent, handler)
	{
		super.GWidgetLayer(...);
		hitThreshold = 256;
		bodyOpacity = 0;
	}

	function assignFontToParent(decoration = false)
	{
		var dst = font;

		with(parent)
		{
			dst.angle = .font.angle;
			if(.font.face[0] == '@')
				dst.face = "@" + .rubyFontFaceCache_;
			else
				dst.face = .rubyFontFaceCache_;
			dst.height = .rubyFontSizeCache_;
			dst.italic = .rubyItalicCache_;
			dst.bold = .rubyBoldCache_;

			if(decoration)
			{
				dst.strikeout = .rubyStrikeoutCache_;
				dst.underline = .rubyUnderlineCache_;
			}
		}

		return this;
	}
}


/**/
class GMessageLayer extends GHyperTextLayer
{
	var linkLayer_;

	var usedCharacterLayers_ = [];
	var notUsedCharacterLayers_ = [];
	var usedRubyTextLayers_ = [];
	var notUsedRubyTextLayers_ = [];
	var standbyRubyTextLayer_ = void;

	var pageGlyphLayer_ = void;
	var lineGlyphLayer_ = void;

	var fixGlyphPosition = false;
	var glyphPositionX = 0;
	var glyphPositionY = 0;

	var links_ = [];
	var currentLinkID_ = 0;
	var currentLinkObject_ = void;

	var enterLinkID_ = void;

	var invisibleByUser_ = false;
	var visibleBackup_ = false;

	function GMessageLayer(window, parent, handler)
	{
		super.GHyperTextLayer(...);

		family.receive(linkLayer_ = new global.GLayer(window, this));
		linkLayer_.visible = true;

		family.receive(new GDestructor(GObjectUtils.dispose, usedCharacterLayers_));
		family.receive(new GDestructor(GObjectUtils.dispose, notUsedCharacterLayers_));

		family.receive(pageGlyphLayer_ = new global.GLayer(window, this));
		loadPageGlyph('PageGlyph');

		family.receive(lineGlyphLayer_ = new global.GLayer(window, this));
		loadLineGlyph('LineGlyph');
	}

	/**/
	function createCharacterLayer(window, parent, handler)
	{
		return new GCharacterLayer(...);
	}

	/**/
	function createRubyTextLayer(window, parent, handler)
	{
		return new GRubyTextLayer(...);
	}

	/**/
	function setSize(width, height)
	{
		super.setSize(...);
		linkLayer_.setSize(width, height) if linkLayer_ !== void;
	}

	/**/
	function allocCharacterLayer_private_()
	{
		var cache = notUsedCharacterLayers_;
		var obj;

		if(cache.count > 0)
			obj = cache.pop();
		else
			obj = createCharacterLayer(window, this, onCharacterLayerEvent);
		obj.assignFontToParent();
		usedCharacterLayers_.push(obj);

		return obj;
	}

	/**/
	function allocRubyTextLayer_private_()
	{
		var cache = notUsedRubyTextLayers_;
		var obj;

		if(cache.count > 0)
			obj = cache.pop();
		else
			obj = createRubyTextLayer(window, this, onRubyTextLayerEvent);
		obj.assignFontToParent();
		usedRubyTextLayers_.push(obj);

		return obj;
	}

	/**/
	function freeCharacterLayers_private_()
	{
		var layers = usedCharacterLayers_;
		var c = layers.count;

		for(var i = 0; i < c; i++)
			layers[i].visible = false;
		notUsedCharacterLayers_.push(layers*);
		layers.clear();
	}

	/**/
	function freeRubyTextLayers_private_()
	{
		var layers = usedRubyTextLayers_;
		var c = layers.count;

		for(var i = 0; i < c; i++)
			layers[i].visible = false;
		notUsedRubyTextLayers_.push(layers*);
		layers.clear();
	}

	/**/
	function beginLink(elm)
	{
		endLink();

		currentLinkObject_ = %[
			storage : elm.storage,
			target : elm.target,
			color : elm.color,
			hint : elm.hint,
			onClickExp : elm.on_click_expression,
			onEnterExp : elm.on_enter_expression,
			onLeaveExp : elm.on_leave_expression
		];
		currentLinkID_++;

		internalBeginLink_private_();
	}

	/**/
	function endLink()
	{
		internalEndLink_private_();

		currentLinkObject_ = void;
	}

	/**/
	function internalBeginLink_private_()
	{
		if(currentLinkObject_ !== void)
		{
			var line = links_[currentLine];
			var link = %[
				baseLine : layout.baseLine,
				lineSize : layout.lineSize,
				start : layout.characterPosition,
				end : void,
				object : currentLinkObject_,
				id : currentLinkID_
			];

			if(line === void)
				line = links_[currentLine] = [];
			line.push(link);
		}
	}

	/**/
	function internalEndLink_private_()
	{
		if(currentLinkObject_ !== void)
		{
			var line = links_[currentLine];

			if(line === void || line.count == 0)
				return;

			var link = line[line.count - 1];

			link.end = layout.characterPosition;
		}
	}

	/**/
	function getLineNumber(x, y)
	{
		var lines = links_;
		var count = lines.count;

		for(var i = 0; i < count; i++)
		{
			if(lines[i] === void)
				continue;

			for(var j = 0; j < lines[i].count; j++)
			{
				var lineInfo = lines[i][j];

				if(layout.includeLine(x, y, lineInfo.baseLine, lineInfo.lineSize))
					return i;
			}
		}

		return -1;
	}

	/**/
	function highLightLink(link)
	{
		linkLayer_.fillRect(
			layout.getLineLeft(link.start, link.baseLine, link.lineSize),
			layout.getLineTop(link.start, link.baseLine, link.lineSize),
			layout.getLineWidth(link.lineSize, link.end - link.start),
			layout.getLineHeight(link.lineSize, link.end - link.start),
			0xFF000000 | clHighlight
		);
	}

	/**/
	function clearHightLight(link)
	{
		linkLayer_.fillRect(
			layout.getLineLeft(link.start, link.baseLine, link.lineSize),
			layout.getLineTop(link.start, link.baseLine, link.lineSize),
			layout.getLineWidth(link.lineSize, link.end - link.start),
			layout.getLineHeight(link.lineSize, link.end - link.start),
			0
		);
	}

	/**/
	function loadPageGlyph(storage)
	{
		with(pageGlyphLayer_)
		{
			.loadImages(storage);
			.conductor.loadScenario(Storages.chopStorageExt(storage));
		}
	}

	/**/
	function showPageGlyph()
	{
		with(pageGlyphLayer_)
		{
			if(layout.shouldWordWrap(.width, .height))
				reline();
			if(fixGlyphPosition)
				.setPos(glyphPositionX, glyphPositionY);
			else
				.setPos(layout.getCurrentLeft(.width, .height), layout.getCurrentTop(.width, .height));
			.conductor.start();
			.show();
		}
	}

	/**/
	function hidePageGlyph()
	{
		with(pageGlyphLayer_)
		{
			.conductor.stop();
			.hide();
		}
	}

	/**/
	function loadLineGlyph(storage)
	{
		with(lineGlyphLayer_)
		{
			.loadImages(storage);
			.conductor.loadScenario(Storages.chopStorageExt(storage));
		}
	}

	/**/
	function showLineGlyph()
	{
		with(lineGlyphLayer_)
		{
			if(layout.shouldWordWrap(.width, .height))
				reline();
			if(fixGlyphPosition)
				.setPos(glyphPositionX, glyphPositionY);
			else
				.setPos(layout.getCurrentLeft(.width, .height), layout.getCurrentTop(.width, .height));
			.conductor.start();
			.show();
		}
	}

	/**/
	function hideLineGlyph()
	{
		with(lineGlyphLayer_)
		{
			.conductor.stop();
			.hide();
		}
	}

	/**/
	function hideByUser()
	{
		if(!invisibleByUser_)
		{
			visibleBackup_ = visible;
			invisibleByUser_ = true;
			visible = false;
		}
	}

	/**/
	function showByUser()
	{
		if(invisibleByUser_)
		{
			visible = visibleBackup_;
			invisibleByUser_ = false;
		}
	}

	/**/
	function store(tick)
	{
		var dic = super.store(...);

		var arr = usedCharacterLayers_;
		var c = arr.count;
		dic.usedCharacterLayers = [];
		for(var i = 0; i < c; i++)
			dic.usedCharacterLayers[i] = arr[i].store(tick);

		arr = usedRubyTextLayers_;
		c = arr.count;
		dic.usedRubyTextLayers = [];
		for(var i = 0; i < c; i++)
			dic.usedRubyTextLayers[i] = arr[i].store(tick);

		dic.pageGlyphLayer = pageGlyphLayer_.store(tick);
		dic.lineGlyphLayer = lineGlyphLayer_.store(tick);

		return dic;
	}

	/**/
	function restore(dic, tick)
	{
		super.restore(...);

		var arr = dic.usedCharacterLayers;
		var c = arr.count;
		var obj;
		freeCharacterLayers_private_();
		for(var i = 0; i < c; i++)
		{
			with(allocCharacterLayer_private_())
				.restore(arr[i]);
		}

		arr = dic.usedRubyTextLayers;
		c = arr.count;
		freeRubyTextLayers_private_();
		for(var i = 0; i < c; i++)
		{
			with(allocRubyTextLayer_private_())
			{
				.restore(arr[i]);
			}
		}

		pageGlyphLayer_.restore(dic.pageGlyphLayer);
		lineGlyphLayer_.restore(dic.lineGlyphLayer);
	}

	/**/
	function onNewLine()
	{
		internalBeginLink_private_();
	}

	/**/
	function onEndLine()
	{
		internalEndLink_private_();
	}

	/**/
	function onRenderCharacter(ch, left, top, width, height)
	{
		var layer = allocCharacterLayer_private_();

		layer.setPos(left, top, width, height);
		layer.caption = ch;

		if(standbyRubyTextLayer_ !== void)
		{
			with(standbyRubyTextLayer_)
			{
				.setPos(
					layout.getRubyLeft(.width, .height, left, top, width, height),
					layout.getRubyTop(.width, .height, left, top, width, height)
				);
				.show();
			}
			standbyRubyTextLayer_ = void;
		}

		layer.show();
	}

	/**/
	function onRenderRubyText(text, width, height)
	{
		var layer = allocRubyTextLayer_private_();

		layer.setSize(width, height);
		layer.caption = text;

		standbyRubyTextLayer_ = layer;
	}

	/**/
	function onEraseText()
	{
		freeCharacterLayers_private_();
		freeRubyTextLayers_private_();

		links_.clear();
		endLink();
		currentLinkID_ = 0;
	}

	/**/
	function onCharacterLayerEvent(obj, message, elm)
	{
	}

	/**/
	function onRubyTextLayerEvent(obj, message, elm)
	{
	}

	/**/
	function onLinkClick(id)
	{
		var cnts = contents_;
		var count = cnts.count;
		var links = links_;
		var data;

		for(var i = 0; i < count; i++)
		{
			data = links[i];
			if(data === void)
				continue;
			for(var j = 0; j < data.count; j++)
			{
				if(data[j].id == id)
				{
					callHandler('onLinkClick', data[j].object);
					return;
				}
			}
		}
	}

	/**/
	function onEnterLink(id)
	{
		var links = links_;
		var count = links.count;
		var data;

		for(var i = 0; i < count; i++)
		{
			data = links[i];
			if(data === void)
				continue;
			for(var j = 0; j < data.count; j++)
			{
				if(data[j].id != id)
					continue;
				highLightLink(data[j]);
				callHandler('onEnterLink', data[j].object);
			}
		}
	}

	/**/
	function onLeaveLink(id)
	{
		var links = links_;
		var count = links.count;
		var layer = linkLayer_;
		var data;

		for(var i = 0; i < count; i++)
		{
			data = links[i];
			if(data === void)
				continue;
			for(var j = 0; j < data.count; j++)
			{
				if(data[j].id != id)
					continue;
				clearHightLight(data[j]);
				callHandler('onLeaveLink', data[j].objec);
			}
		}
	}

	/**/
	function onMouseUp(x, y, button, shift)
	{
		switch(button)
		{
		case mbLeft:
			if(enterLinkID_ !== void)
			{
				onLinkClick(enterLinkID_);
			}
			else
			{
				window.leftClick(x, y, shift);
			}
			break;
		}
	}

	/**/
	function onMouseMove(x, y, shift)
	{
		super.onMouseMove(...);

		var line = getLineNumber(x, y);

		if(line === -1)
		{
			if(enterLinkID_ !== void)
			{
				onLeaveLink(enterLinkID_);
				enterLinkID_ = void;
			}
			return;
		}

		var link = links_[line];

		if(link === void)
		{
			if(enterLinkID_ !== void)
			{
				onLeaveLink(enterLinkID_);
				enterLinkID_ = void;
			}
			return;
		}

		var count = link.count;

		for(var i = 0; i < count; i++)
		{
			if(layout.includePosition(x, y, link[i].start, link[i].end))
			{
				if(enterLinkID_ != link[i].id)
				{
					onLeaveLink(enterLinkID_) if enterLinkID_ !== void;
					onEnterLink(enterLinkID_ = link[i].id);
				}
				return;
			}
		}

		if(enterLinkID_ !== void)
		{
			onLeaveLink(enterLinkID_);
			enterLinkID_ = void;
		}
	}

	property invisibleByUser
	{
		getter		{ return invisibleByUser_; }
	}
}



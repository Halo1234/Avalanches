/*
 $Author$
 $Revision$
*/


/**
 * GLayer/GFocus を項目として扱う事を目標としています。
 *
 * 一次元のソフトフォーカスエミュレーターです。
 * 二次元管理を行う場合は GFocus2D を利用してください。
**/
class GFocus
{
	var name;

	var _items = [];
	var _focusItemIndex = -1;

	var clickToKill = true;					// click() 呼び出し後に kill() するかどうか
	var terminate = false;					// 最後の項目の次に仮想の項目を追加するかどうか
	var _visible = true;
	var _enabled = true;

	var _originalEnabledProperties = [];	// 元のプロパティ
	var _originalVisibleProperties = [];	//
	var _originalEnabledValueCache = [];	// 元のプロパティの値
	var _originalVisibleValueCache = [];	//

	function GFocus(name = void)
	{
		this.name = (name === void ? GObjectUtils.getClassName(this) : name);
	}

	function finalize()
	{
		clear();
	}

	/**
	 * add()/insert()/remove() は item 引数をそのまま返します。
	 * ※実際に追加／削除が行われなくても必ず返します。
	**/
	function add(item)
	{
		with(_items)
		{
			if(.find(item) == -1)
			{
				.add(item);

				// このフォーカスが無効ならば項目も無効化する
				exchangeEnabledPropertyBypass_private_(.count - 1) if !enabled;
				// このフォーカスが不可視ならば項目も不可視にする
				exchangeVisiblePropertyBypass_private_(.count - 1) if !visible;
			}
		}

		return item;
	}

	function insert(index, item)
	{
		with(_items)
		{
			if(.find(item) == -1)
			{
				.insert(index, item);

				// このフォーカスが無効ならば項目も無効化する
				exchangeEnabledPropertyBypass_private_(index) if !enabled;
				// このフォーカスが不可視ならば項目も不可視にする
				exchangeVisiblePropertyBypass_private_(index) if !visible;
			}
		}

		return item;
	}

	function remove(item)
	{
		var items = _items;
		var index = items.find(item);

		if(index != -1)
		{
			restoreEnabledProperty_private_(index);
			restoreVisibleProperty_private_(index);
			items.remove(item);

			_focusItemIndex = items.count - 1 if _focusItemIndex >= items.count;

			if(_focusItemIndex != -1 && enabled && visible)
			{
				// NOTE:
				// GFocus がフォーカスされる場合は移動方向がわからないので何もしない。
				if(!(items[_focusItemIndex] instanceof 'GFocus'))
					onFocused(items[_focusItemIndex]);
			}
		}

		return item;
	}

	function clear()
	{
		var items = _items;

		for(var i = 0; i < items.count; i++)
		{
			if(isvalid items[i])
			{
				restoreEnabledProperty_private_(i);
				restoreVisibleProperty_private_(i);
			}
		}
		items.clear();
		_focusItemIndex = -1;	// kill() を呼ばない
	}

	function at(index)
	{
		return _items[index];
	}

	function find(obj)
	{
		var items = _items;

		for(var i = 0; i < items.count; i++)
		{
			if(items[i] === obj)
				return i;
		}

		return -1;
	}

	function each(block, arg*)
	{
		var items = _items;

		for(var i = 0; i < items.count; i++)
			block(items[i], i, arg*);
	}

	/**
	 * 一次元管理なので moveLeft()/moveUp と moveRight()/moveDown() は
	 * 基本的には同じ処理を行っています。
	 * 下位の GFocus/GFocus2D に方向を伝播させるために
	 * 同じような処理でもこのような実装になっています。
	**/
	function moveLeft(loop = false)
	{
		var items = _items;
		var count = items.count;
		var f = _focusItemIndex;

		// 移動不可
		if(!_visible || !_enabled || count <= 0)
			return false;
		// 前にいけない
		if(f == 0 && !loop)
		{
			// 最初の項目が GFocus なら moveLeft を呼び出してやる
			if(items[0] instanceof "GFocus")
			{
				if(items[0].moveLeft(false))
					return true;
			}
			// 移動できない
			kill();
			return false;
		}

		// この時点でフォーカスされている項目は最初の項目ではない事が確定
		// 現在の項目が GFocus なら moveLeft を呼び出してやる
		if(f != -1 && items[f] instanceof "GFocus")
		{
			if(items[f].moveLeft(false))
				return true;
			// 前にいけなかった
			// この場合このインスタンスの次の項目へ移動させる必要があるが
			// items[f]がフォーカスを持っている状態は好ましくないので殺す
			items[f].kill();
		}

		// 前の項目に移動する
		f--;
		for(var i = 0; i < count; i++, f--)
		{
			if(f < 0)
			{
				// ループしないなら抜ける。
				// ただしもともとフォーカスを持っていない場合１回はループする。
				if(!loop && _focusItemIndex != -1)
					break;
				f = terminate ? count : count - 1;
			}

			if(terminate && f == count)
			{
				_focusItemIndex = f;
				onTerminateObjectFocused();
				return true;
			}

			// 表示されている、かつ有効な状態であれば決定
			if(items[f].visible && items[f].enabled)
			{
				if(items[f] instanceof "GFocus")
				{
					if(items[f].moveLeft(false))
					{
						_focusItemIndex = f;
						return true;
					}
				}
				else
				{
					// 更新
					onFocused(items[_focusItemIndex = f]);
					return true;
				}
			}
		}

		kill();

		return false;
	}

	function moveRight(loop = false)
	{
		var items = _items;
		var count = items.count;
		var f = _focusItemIndex;

		// 移動不可
		if(!_visible || !_enabled || count <= 0)
			return false;
		// 次にいけない
		if(f == (count - 1) && !loop)
		{
			// 最後の項目が GFocus なら moveRight を呼び出してやる
			if(items[f] instanceof "GFocus")
			{
				if(items[f].moveRight(false))
					return true;
			}
			// 移動できない
			kill();
			return false;
		}

		// この時点でフォーカスされている項目は最後の項目ではないか、
		// ターミネートオブジェクトのどちらか。
		// 現在の項目が GFocus なら moveRight を呼び出してやる
		if(f != -1 && items[f] instanceof "GFocus")
		{
			if(items[f].moveRight(false))
				return true;
			// 次にいけなかった
			// この場合このインスタンスの次の項目へ移動させる必要があるが
			// items[f]がフォーカスを持っている状態は好ましくないので殺す
			items[f].kill();
		}

		// 次の項目に移動する
		f++;
		for(var i = 0; i < count; i++, f++)
		{
			if(f >= items.count)
			{
				if(!terminate || (terminate && f > items.count))
				{
					// ループしないなら抜ける
					if(!loop)
						break;
					f = 0;
				}
			}

			if(terminate && f == count)
			{
				_focusItemIndex = f;
				onTerminateObjectFocused();
				return true;
			}

			// 表示されている、かつ有効な状態であれば処理する。
			if(items[f].visible && items[f].enabled)
			{
				if(items[f] instanceof "GFocus")
				{
					if(items[f].moveRight(false))
					{
						_focusItemIndex = f;
						return true;
					}
				}
				else
				{
					// 更新
					onFocused(items[_focusItemIndex = f]);
					return true;
				}
			}
		}

		kill();

		return false;
	}

	function moveUp(loop = false)
	{
		var items = _items;
		var count = items.count;
		var f = _focusItemIndex;

		// 移動不可
		if(!_visible || !_enabled || count <= 0)
			return false;
		// 前にいけない
		if(f == 0 && !loop)
		{
			// 最初の項目が GFocus なら moveUp を呼び出してやる
			if(items[0] instanceof "GFocus")
			{
				if(items[0].moveUp(false))
					return true;
			}
			// 移動できない
			// 必要ならばフォーカスを殺す
			kill();
			return false;
		}

		// この時点でフォーカスされている項目は最初の項目ではない事が確定
		// 現在の項目が GFocus なら moveUp を呼び出してやる
		if(f != -1 && items[f] instanceof "GFocus")
		{
			if(items[f].moveUp(false))
				return true;
			// 前にいけなかった
			// この場合このインスタンスの次の項目へ移動させる必要があるが
			// items[f]がフォーカスを持っている状態は好ましくないので殺す
			items[f].kill();
		}

		// 前の項目に移動する
		f--;
		for(var i = 0; i < count; i++, f--)
		{
			if(f < 0)
			{
				// ループしないなら抜ける。
				// ただしもともとフォーカスを持っていない場合１回はループする。
				if(!loop && _focusItemIndex != -1)
					break;
				f = terminate ? count : count - 1;
			}

			if(terminate && f == count)
			{
				_focusItemIndex = f;
				onTerminateObjectFocused();
				return true;
			}

			// 表示されている、かつ有効な状態であれば決定
			if(items[f].visible && items[f].enabled)
			{
				if(items[f] instanceof "GFocus")
				{
					if(items[f].moveUp(false))
					{
						_focusItemIndex = f;
						return true;
					}
				}
				else
				{
					// 更新
					onFocused(items[_focusItemIndex = f]);
					return true;
				}
			}
		}

		kill();

		return false;
	}

	function moveDown(loop = false)
	{
		var items = _items;
		var count = items.count;
		var f = _focusItemIndex;

		// 移動不可
		if(!_visible || !_enabled || count <= 0)
			return false;
		// 次にいけない
		if(f == (count - 1) && !loop)
		{
			// 最後の項目が GFocus なら moveDown を呼び出してやる
			if(items[f] instanceof "GFocus")
			{
				if(items[f].moveDown(false))
					return true;
			}
			// 移動できない
			// 必要ならばフォーカスを殺す
			kill();
			return false;
		}

		// この時点でフォーカスされている項目は最後の項目ではないか、
		// ターミネートオブジェクトのどちらか。
		// 現在の項目が GFocus なら moveDown を呼び出してやる
		if(f != -1 && items[f] instanceof "GFocus")
		{
			if(items[f].moveDown(false))
				return true;
			// 次にいけなかった
			// この場合このインスタンスの次の項目へ移動させる必要があるが
			// items[f]がフォーカスを持っている状態は好ましくないので殺す
			items[f].kill();
		}

		// 次の項目に移動する
		f++;
		for(var i = 0; i < count; i++, f++)
		{
			if(f >= items.count)
			{
				if(!terminate || (terminate && f > items.count))
				{
					// ループしないなら抜ける
					if(!loop)
						break;
					f = 0;
				}
			}

			if(terminate && f == count)
			{
				_focusItemIndex = f;
				onTerminateObjectFocused();
				return true;
			}

			// 表示されている、かつ有効な状態であれば処理する。
			if(items[f].visible && items[f].enabled)
			{
				if(items[f] instanceof "GFocus")
				{
					if(items[f].moveDown(false))
					{
						_focusItemIndex = f;
						return true;
					}
				}
				else
				{
					// 更新
					onFocused(items[_focusItemIndex = f]);
					return true;
				}
			}
		}

		kill();

		return false;
	}

	function click()
	{
		var item = focusItem;

		if(item === void)
			return false;

		var ret = item.click();

		kill() if clickToKill;

		return (ret === void ? false : ret);
	}

	function kill()
	{
		var item = focusItem;

		if(item !== void)
		{
			if(item instanceof "GFocus")
				item.kill();
			else
				item.updateState = true;
		}

		_focusItemIndex = -1;

		onKillFocus();
	}

	function exchangeEnabledPropertyBypass_private_(index)
	{
		var items = _items;
		var original = _originalEnabledProperties;

		if(index < 0 || index >= items.count)
			throw new Exception('Access violation in GFocus#exchangeEnabledPropertyBypass_private_().');

		if(!((&original[index]) instanceof "Property"))
		{
			_originalEnabledValueCache[index] = items[index].enabled;
			items[index].enabled = false;
			original[index] = &items[index].enabled;
			&items[index].enabled = ((&_widgetEnabledPropertyBypass) incontextof (new GInstantContext(%[focus : this, origin : items[index]])));
		}
	}

	function restoreEnabledProperty_private_(index)
	{
		var items = _items;
		var original = _originalEnabledProperties;

		if(index < 0 || index >= items.count)
			throw new Exception('Access violation in GFocus#restoreEnabledProperty_private_().');

		if((&original[index]) instanceof "Property")
		{
			&items[index].enabled = &original[index];
			&original[index] = void;
			items[index].enabled = _originalEnabledValueCache[index];
		}
	}

	function exchangeVisiblePropertyBypass_private_(index)
	{
		var items = _items;
		var original = _originalVisibleProperties;

		if(index < 0 || index >= items.count)
			throw new Exception('Access violation in GFocus#exchangeEnabledPropertyBypass_private_().');

		if(!((&original[index]) instanceof "Property"))
		{
			_originalVisibleValueCache[index] = items[index].visible;
			items[index].visible = false;
			original[index] = &items[index].visible;
			&items[index].visible = ((&_widgetVisiblePropertyBypass) incontextof (new GInstantContext(%[focus : this, origin : items[index]])));
		}
	}

	function restoreVisibleProperty_private_(index)
	{
		var items = _items;
		var original = _originalVisibleProperties;

		if(index < 0 || index >= items.count)
			throw new Exception('Access violation in GFocus#restoreEnabledProperty_private_().');

		if((&original[index]) instanceof "Property")
		{
			&items[index].visible = &original[index];
			&original[index] = void;
			items[index].visible = _originalVisibleValueCache[index];
		}
	}

	/**
	 * フォーカスが移動した時に呼び出されます。
	 * terminated な状態になった時は呼び出されません。
	**/
	function onFocused(item)
	{
		item.centeringMouseCursor();
		item.updateState = true;

		return true;
	}

	/**
	 * terminated な状態になった時に呼び出されます。
	**/
	function onTerminateObjectFocused()
	{
	}

	/**
	 * kill() された時に呼び出されます。
	 * terminated な状態になった時は呼び出されません。
	**/
	function onKillFocus()
	{
	}

	property count
	{
		getter		{ return _items.count; }
	}

	property focused
	{
		getter		{ return (!_enabled || _focusItemIndex == -1 ? false : true); }
	}

	property focusItem
	{
		getter		{ return (focused ? (terminated ? void : _items[_focusItemIndex]) : void); }
	}

	property focusWidget
	{
		// NOTE:
		// このプロパティが GFocus のインスタンスを返す事はありません。
		// ただし最終的に teminated な場合は void を返します。
		getter		{ return ((focusItem instanceof "GFocus") ? focusItem.focusWidget : focusItem); }
	}

	property terminated
	{
		getter		{ return (terminate && _focusItemIndex == _items.count); }
	}

	/* 表示／非表示状態 */
	property visible
	{
		setter(x)
		{
			if(x)
			{
				if(!_visible)
				{
					var items = _items;
					for(var i = 0; i < items.count; i++)
						restoreVisibleProperty_private_(i);
				}
				_visible = true;
			}
			else
			{
				if(_visible)
				{
					var items = _items;
					for(var i = 0; i < items.count; i++)
						exchangeVisiblePropertyBypass_private_(i);
					kill();
				}
				_visible = false;
			}
		}
		getter		{ return _visible; }
	}

	/* 有効／無効状態 */
	property enabled
	{
		setter(x)
		{
			if(x)
			{
				if(!_enabled)
				{
					var items = _items;
					for(var i = 0; i < items.count; i++)
						restoreEnabledProperty_private_(i);
				}
				_enabled = true;
			}
			else
			{
				if(_enabled)
				{
					var items = _items;
					for(var i = 0; i < items.count; i++)
						exchangeEnabledPropertyBypass_private_(i);
					kill();
				}
				_enabled = false;
			}
		}
		getter		{ return _enabled; }
	}

	property _widgetVisiblePropertyBypass
	{
		setter(x)	{ focus._originalVisibleValueCache[focus.find(origin)] = x; }
		getter		{ return false; }
	}

	property _widgetEnabledPropertyBypass
	{
		setter(x)	{ focus._originalEnabledValueCache[focus.find(origin)] = x; }
		getter		{ return false; }
	}
}

/**
 * GFocus のデバッグプリント用
**/
function dumpGFocusItems(sFocus, level = 0)
{
	var indent = '';
	var obj;

	for(var i = 0; i < level; i++)
		indent += ' ';

	dm(@"&indent;[&sFocus.name;] (enabled:&sFocus.enabled; visible:&sFocus.visible; clickToKill:&sFocus.clickToKill; terminate:&sFocus.terminate;)");
	indent += ' ';

	for(var i = 0; i < sFocus.count; i++)
	{
		obj = sFocus.at(i);
		if(obj instanceof 'GFocus')
			dumpGFocusItems(obj, level + 1);
		else
			dm(@"&indent;&obj.name; [&obj.caption;] (enabled:&obj.enabled; visible:&obj.visible;)");
	}
}


